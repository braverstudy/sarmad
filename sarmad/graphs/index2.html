<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªØªØ¨Ø¹ ØµØ¯Ù‰ Ø§Ù„Ø§Ù†ØªØ´Ø§Ø± - Viral Spread Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050a14;
            color: white;
            font-family: 'Cairo', sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 195, 255, 0.7);
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 1px;
            color: #4facfe;
        }

        .header p {
            margin: 5px 0 0;
            font-size: 14px;
            color: #aaa;
            transition: color 0.3s ease;
        }

        .timeline-bar {
            position: relative;
            width: 100%;
            height: 60px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 40px;
            box-sizing: border-box;
        }

        .time-label {
            font-size: 14px;
            color: #4facfe;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid rgba(79, 172, 254, 0.3);
        }

        .controls {
            pointer-events: auto;
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        button {
            border: none;
            padding: 10px 20px;
            color: white;
            border-radius: 25px;
            font-family: 'Cairo', sans-serif;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-reset {
            background: linear-gradient(45deg, #00f260, #0575e6);
            box-shadow: 0 4px 15px rgba(0, 242, 96, 0.4);
        }

        .btn-trace {
            background: linear-gradient(45deg, #ff416c, #ff4b2b);
            box-shadow: 0 4px 15px rgba(255, 65, 108, 0.4);
        }

        button:hover {
            transform: translateX(-50%) scale(1.05);
            filter: brightness(1.2);
        }

        button:active {
            transform: translateX(-50%) scale(0.95);
        }

        #tooltip {
            position: absolute;
            background: rgba(16, 25, 40, 0.95);
            border: 1px solid #4facfe;
            padding: 10px;
            border-radius: 8px;
            display: none;
            pointer-events: none;
            max-width: 250px;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.2);
            font-size: 12px;
            color: #eee;
            z-index: 10;
        }

        .tweet-header {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 5px;
        }

        .tweet-avatar {
            width: 20px;
            height: 20px;
            background: #4facfe;
            border-radius: 50%;
            margin-left: 8px;
        }

        /* Ù†Ø§ÙØ°Ø© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø¨Ø­Ø« */
        #search-info {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #ff416c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            display: none;
            text-align: center;
            z-index: 5;
            min-width: 250px;
        }

        #search-info h3 {
            margin: 0 0 10px 0;
            color: #ff416c;
            font-size: 16px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .stat-val {
            font-weight: bold;
            color: #4facfe;
        }
    </style>
</head>

<body>

    <div id="canvas-container">
        <canvas id="networkCanvas"></canvas>
    </div>

    <div id="ui-layer">
        <div class="header">
            <h1>ØªØ­Ù„ÙŠÙ„ Ø§Ù†ØªØ´Ø§Ø± Ø§Ù„Ù…Ø­ØªÙˆÙ‰ - Network Graph</h1>
            <p id="status-text">Ù…Ù† Ø§Ù„Ù…ØµØ¯Ø± (Ø§Ù„ÙŠØ³Ø§Ø±) Ø¥Ù„Ù‰ Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„ÙÙŠØ±ÙˆØ³ÙŠ (Ø§Ù„ÙŠÙ…ÙŠÙ†)</p>
        </div>

        <div id="search-info">
            <h3>Algorithm Status</h3>
            <div class="stat-row">
                <span>Ø§Ù„Ù…Ø±Ø­Ù„Ø©:</span>
                <span id="algo-phase" class="stat-val">Idle</span>
            </div>
            <div class="stat-row">
                <span>ØªØºØ±ÙŠØ¯Ø§Øª ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚:</span>
                <span id="search-count" class="stat-val">0</span>
            </div>
            <div class="stat-row">
                <span>Ø­Ø¯ Ø§Ù„Ø¨Ø­Ø« (l):</span>
                <span id="search-bound" class="stat-val">0</span>
            </div>
        </div>

        <div class="controls">
            <button class="btn-trace" onclick="startExpansionSearch()">Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…ØµØ¯Ø± (Expansion Search) ğŸ”</button>
            <button class="btn-reset" onclick="resetSimulation()">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© âŸ³</button>
        </div>

        <div class="timeline-bar" dir=ltr>
            <div class="time-label">Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (Ø§Ù„Ù…Ù†Ø´ÙˆØ± Ø§Ù„Ø£ØµÙ„ÙŠ)</div>
            <div
                style="flex-grow: 1; height: 1px; background: linear-gradient(to left, #4facfe, transparent); margin: 0 20px;">
            </div>
            <div class="time-label">Ø§Ù„Ø¢Ù† (Ø§Ù†ØªØ´Ø§Ø± ÙˆØ§Ø³Ø¹)</div>
        </div>
    </div>

    <div id="tooltip">
        <div class="tweet-header">
            <div class="tweet-avatar"></div>
            <span id="tooltip-user">User123</span>
        </div>
        <div id="tooltip-text">Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØºØ±ÙŠØ¯Ø©...</div>
    </div>

    <script>
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const statusText = document.getElementById('status-text');
        const searchInfoBox = document.getElementById('search-info');
        const searchCountText = document.getElementById('search-count');
        const algoPhaseText = document.getElementById('algo-phase');
        const searchBoundText = document.getElementById('search-bound');

        let width, height;
        let nodes = [];
        let edges = [];
        let animationFrameId;
        let hoveredNode = null;

        // Ø­Ø§Ù„Ø© Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø¨Ø­Ø« (Expansion Search State)
        let searchState = {
            active: false,
            windowLeft: 0,   // l (Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ù…ØªØºÙŠØ±Ø©)
            windowRight: 0,  // r (Ø§Ù„Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø«Ø§Ø¨ØªØ© ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹)
            phase: 'idle',   // idle, expanding, saturated, trimming
            prevCount: -1,
            stableFrames: 0, // Ù„Ø¹Ø¯ Ø§Ù„Ø¥Ø·Ø§Ø±Ø§Øª Ø§Ù„ØªÙŠ ÙŠØ«Ø¨Øª ÙÙŠÙ‡Ø§ Ø§Ù„Ø¹Ø¯Ø¯
            speed: 5
        };

        const CONFIG = {
            maxNodes: 600,       // Ø¹Ø¯Ø¯ Ø£Ù‚Ù„ Ù„ØªÙˆØ¶ÙŠØ­ Ø§Ù„ØªØ¨Ø§Ø¹Ø¯
            growSpeed: 2,
            branchChance: 0.12,
            colors: {
                root: '#FFD700',
                highLevel: '#00C3FF',
                leaf: '#6e48aa',
                edge: 'rgba(79, 200, 255, 0.4)',
                highlightPath: '#FF4500',
                searchWindow: 'rgba(0, 195, 255, 0.15)',
                searchLine: '#ff416c',
                dimmed: 'rgba(255, 255, 255, 0.1)' // Ù„ÙˆÙ† Ø§Ù„Ø¹Ù‚Ø¯ Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø§ÙØ°Ø©
            }
        };

        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        class Node {
            constructor(x, y, level, parent = null) {
                this.x = x;
                this.y = y;
                this.originX = x;
                this.originY = y;
                this.level = level;
                this.parent = parent;

                if (level === 0) {
                    this.radius = 25;
                    this.color = CONFIG.colors.root;
                    this.glow = 30;
                } else {
                    this.radius = Math.max(2, 12 * Math.pow(0.85, level));
                    this.color = level < 5 ? CONFIG.colors.highLevel : 'rgba(150, 200, 255, 0.6)';
                    this.glow = level < 3 ? 10 : 0;
                }

                this.opacity = 0;
                this.targetOpacity = 1;
                this.vx = (Math.random() - 0.5) * 0.2;
                this.vy = (Math.random() - 0.5) * 0.2;

                this.inSearchWindow = true; // Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ù‚Ø¯Ø© Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù„Ø¨Ø­Ø«

                this.data = {
                    user: level === 0 ? "Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„Ø£ØµÙ„ÙŠ" : `Ù…Ø³ØªØ®Ø¯Ù…_${Math.floor(Math.random() * 9000)}`,
                    content: level === 0 ? "Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ù‚ØµØ© ÙˆØ§Ù„Ø­Ø¯Ø«..." : "ØªÙØ§Ø¹Ù„ØŒ Ø±ÙŠØªÙˆÙŠØªØŒ Ø£Ùˆ Ø±Ø¯..."
                };
            }

            update() {
                if (this.opacity < this.targetOpacity) {
                    this.opacity += 0.05;
                }
                this.x += this.vx;
                this.y += this.vy;
                const drift = 5;
                if (this.x > this.originX + drift || this.x < this.originX - drift) this.vx *= -1;
                if (this.y > this.originY + drift || this.y < this.originY - drift) this.vy *= -1;
            }

            draw(ctx) {
                ctx.globalAlpha = this.opacity;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                // Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø´ÙØ§ÙÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¨Ø­Ø«
                if (searchState.active && !this.inSearchWindow) {
                    ctx.fillStyle = '#333';
                    ctx.globalAlpha = 0.3;
                    ctx.fill();
                    ctx.strokeStyle = '#444';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else {
                    if (this.glow > 0) {
                        ctx.shadowBlur = this.glow;
                        ctx.shadowColor = this.color;
                    } else {
                        ctx.shadowBlur = 0;
                    }
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }

                ctx.shadowBlur = 0;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 1;
            }
        }

        function init() {
            nodes = [];
            edges = [];
            searchState.active = false;
            searchInfoBox.style.display = 'none';
            statusText.innerText = "Ù…Ù† Ø§Ù„Ù…ØµØ¯Ø± (Ø§Ù„ÙŠØ³Ø§Ø±) Ø¥Ù„Ù‰ Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„ÙÙŠØ±ÙˆØ³ÙŠ (Ø§Ù„ÙŠÙ…ÙŠÙ†)";
            statusText.style.color = "#aaa";

            // Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙ Ø§Ù„Ø£ÙŠØ³Ø± Ù…Ø¹ Ù‡Ø§Ù…Ø´
            const rootNode = new Node(100, height / 2, 0);
            nodes.push(rootNode);
        }

        // --- Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ù„ØªÙˆØ³ÙŠØ¹ (Expansion Search) ---
        function startExpansionSearch() {
            if (nodes.length < 20) {
                alert("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù†ØªØ´Ø§Ø± Ø§Ù„Ø´Ø¨ÙƒØ© Ù‚Ù„ÙŠÙ„Ø§Ù‹!");
                return;
            }

            searchState.active = true;
            searchState.windowRight = width; // r (Ø£Ù‚ØµÙ‰ Ø§Ù„ÙŠÙ…ÙŠÙ†)
            searchState.windowLeft = width - 100; // Ù†Ø¨Ø¯Ø£ Ø¨Ù€ l Ù‚Ø±ÙŠØ¨ Ø¬Ø¯Ø§Ù‹ Ù…Ù† r
            searchState.phase = 'expanding';
            searchState.prevCount = -1;
            searchState.stableFrames = 0;
            searchState.speed = 2; // Ø³Ø±Ø¹Ø© Ù…Ø¨Ø¯Ø¦ÙŠØ©

            searchInfoBox.style.display = 'block';
            statusText.innerText = "Ø¬Ø§Ø±ÙŠ ØªÙˆØ³ÙŠØ¹ Ø§Ù„Ù†Ø·Ø§Ù‚ (l) Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„ØªÙØ§Ø¹Ù„...";
            statusText.style.color = CONFIG.colors.searchLine;
        }

        function growNetwork() {
            if (searchState.active) return; // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ù…Ùˆ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«
            if (nodes.length >= CONFIG.maxNodes) return;

            const activeNodes = nodes.filter(n => n.x < width - 100 && Math.random() < 0.4);

            for (let parent of activeNodes) {
                if (Math.random() < CONFIG.branchChance) {
                    const angleSpread = Math.PI / 1.1;
                    const angle = (Math.random() - 0.5) * angleSpread;

                    // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ¨Ø§Ø¹Ø¯ (More Spacing)
                    const distance = 80 + Math.random() * 120; // Ù…Ø³Ø§ÙØ§Øª Ø£ÙƒØ¨Ø±

                    const newX = parent.x + Math.abs(Math.cos(angle) * distance) + (Math.random() * 20);
                    const newY = parent.y + Math.sin(angle) * distance;

                    if (newY > 40 && newY < height - 40 && newX < width - 40) {
                        const newLevel = parent.level + 1;
                        const newNode = new Node(newX, newY, newLevel, parent);
                        nodes.push(newNode);
                        edges.push({ from: parent, to: newNode, opacity: 0 });
                        if (nodes.length >= CONFIG.maxNodes) break;
                    }
                }
            }
        }

        function updateSearchLogic() {
            if (!searchState.active) return;

            // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¹Ù‚Ø¯ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù†Ø§ÙØ°Ø©
            let currentCount = 0;
            nodes.forEach(n => {
                if (n.x >= searchState.windowLeft && n.x <= searchState.windowRight) {
                    n.inSearchWindow = true;
                    currentCount++;
                } else {
                    n.inSearchWindow = false;
                }
            });

            // ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            searchCountText.innerText = currentCount;
            searchBoundText.innerText = Math.floor(searchState.windowLeft);

            // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© ---

            if (searchState.phase === 'expanding') {
                algoPhaseText.innerText = "Expanding Gap (l â†)";
                algoPhaseText.style.color = "#ffdd00";

                // ØªØ­Ø±ÙŠÙƒ l Ù„Ù„ÙŠØ³Ø§Ø± (ØªÙˆØ³ÙŠØ¹ Ø§Ù„ÙØ¬ÙˆØ©)
                searchState.windowLeft -= searchState.speed;
                searchState.speed *= 1.02; // ØªØ³Ø±ÙŠØ¹ Ø£Ø³ÙŠ Ø¨Ø³ÙŠØ·

                // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† "Ø¹Ø¯Ù… Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØºØ±ÙŠØ¯Ø§Øª" (Saturation)
                if (currentCount === searchState.prevCount) {
                    searchState.stableFrames++;
                } else {
                    searchState.stableFrames = 0;
                    searchState.prevCount = currentCount;
                }

                // Ø´Ø±Ø· Ø§Ù„ØªÙˆÙ‚Ù Ø¹Ù† Ø§Ù„ØªÙˆØ³ÙŠØ¹:
                // 1. ÙˆØµÙ„Ù†Ø§ Ù„Ù„Ø­Ø§ÙØ© Ø§Ù„ÙŠØ³Ø±Ù‰ Ù„Ù„Ø´Ø§Ø´Ø©
                // 2. Ø£Ùˆ Ø§Ù„Ø¹Ø¯Ø¯ Ø«Ø¨Øª Ù„ÙØªØ±Ø© Ø·ÙˆÙŠÙ„Ø© (Ù…Ù…Ø§ ÙŠØ¹Ù†ÙŠ Ø£Ù†Ù†Ø§ ØºØ·ÙŠÙ†Ø§ ÙƒÙ„ Ø§Ù„Ø¹Ù‚Ø¯)
                if (searchState.windowLeft <= 20 || (searchState.stableFrames > 60 && currentCount > 10)) {
                    searchState.phase = 'trimming';
                    searchState.speed = 1; // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ø³Ø±Ø¹Ø© Ù„Ù„ØªØ¯Ù‚ÙŠÙ‚
                    statusText.innerText = "Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØºØ±ÙŠØ¯Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©. Ø¬Ø§Ø±ÙŠ Ø²ÙŠØ§Ø¯Ø© (l) Ù„ÙƒØ´Ù Ø£ÙˆÙ„ ØªØºØ±ÙŠØ¯Ø©...";
                    statusText.style.color = "#00f260";

                    // ÙˆÙ…ÙŠØ¶ ØªØ£ÙƒÙŠØ¯
                    document.body.style.backgroundColor = "#1a253a";
                    setTimeout(() => document.body.style.backgroundColor = "#050a14", 100);
                }

            } else if (searchState.phase === 'trimming') {
                algoPhaseText.innerText = "Detecting First Tweet (l â†’)";
                algoPhaseText.style.color = "#00f260";

                // ØªØ­Ø±ÙŠÙƒ l Ù„Ù„ÙŠÙ…ÙŠÙ† (ØªÙ‚Ù„ÙŠØµ Ø§Ù„ÙØ±Ø§Øº)
                // Ø§Ù„Ù‡Ø¯Ù: Ø§Ù„ØªÙˆÙ‚Ù Ø¹Ù†Ø¯ Ø£ÙˆÙ„ Ø¹Ù‚Ø¯Ø© (Ø§Ù„Ù…ØµØ¯Ø±)
                const rootX = nodes[0].x;

                // Ù†Ù‚ØªØ±Ø¨ Ù…Ù† Ø§Ù„Ù…ØµØ¯Ø±
                if (searchState.windowLeft < rootX - 5) { // Ù‡Ø§Ù…Ø´ Ø®Ø·Ø£ Ø¨Ø³ÙŠØ·
                    searchState.windowLeft += searchState.speed;
                    searchState.speed += 0.5; // ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ø­Ø±ÙƒØ© ÙÙŠ Ø§Ù„ÙØ±Ø§Øº
                } else {
                    // ØªÙ… Ø§Ù„ÙƒØ´Ù!
                    searchState.phase = 'found';
                    searchState.active = false;
                    searchState.windowLeft = rootX - 30; // ØªØ«Ø¨ÙŠØª Ø§Ù„Ù†Ø§ÙØ°Ø© Ø­ÙˆÙ„ Ø§Ù„Ù…ØµØ¯Ø±

                    statusText.innerText = "ØªÙ… Ø±ØµØ¯ Ø§Ù„Ù…ØµØ¯Ø±! (First Tweet Detected)";
                    searchInfoBox.style.display = 'none';

                    // ØªÙ…ÙŠÙŠØ² Ø§Ù„Ù…ØµØ¯Ø±
                    nodes[0].glow = 100;
                    nodes[0].radius = 60;
                }
            }
        }

        function drawSearchOverlay(ctx) {
            if (!searchState.active) return;

            const l = searchState.windowLeft;
            const r = searchState.windowRight;

            // ØªØ¸Ù„ÙŠÙ„ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø§ÙØ°Ø© (ÙŠØ³Ø§Ø± l)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, l, height);

            // ØªØ¸Ù„ÙŠÙ„ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù†Ø´Ø·Ø©
            ctx.fillStyle = CONFIG.colors.searchWindow;
            ctx.fillRect(l, 0, r - l, height);

            // Ø±Ø³Ù… Ø®Ø· Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù…ØªØ­Ø±Ùƒ (l)
            ctx.beginPath();
            ctx.moveTo(l, 0);
            ctx.lineTo(l, height);
            ctx.strokeStyle = CONFIG.colors.searchLine;
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Ø±Ø³Ù… Ø³Ù‡Ù… ÙŠØ´ÙŠØ± Ù„Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø­Ø±ÙƒØ©
            const arrowY = height / 2;
            ctx.beginPath();
            if (searchState.phase === 'expanding') {
                // Ø³Ù‡Ù… Ù„Ù„ÙŠØ³Ø§Ø±
                ctx.moveTo(l + 20, arrowY);
                ctx.lineTo(l + 5, arrowY);
                ctx.lineTo(l + 15, arrowY - 10);
                ctx.moveTo(l + 5, arrowY);
                ctx.lineTo(l + 15, arrowY + 10);
            } else {
                // Ø³Ù‡Ù… Ù„Ù„ÙŠÙ…ÙŠÙ†
                ctx.moveTo(l - 20, arrowY);
                ctx.lineTo(l - 5, arrowY);
                ctx.lineTo(l - 15, arrowY - 10);
                ctx.moveTo(l - 5, arrowY);
                ctx.lineTo(l - 15, arrowY + 10);
            }
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            ctx.globalCompositeOperation = 'screen';

            updateSearchLogic();

            // 1. Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ·
            ctx.lineWidth = 0.8;
            edges.forEach(edge => {
                if (edge.opacity < 1) edge.opacity += 0.02;

                // Ø®Ø·ÙˆØ· Ø¨Ø§Ù‡ØªØ© Ø®Ø§Ø±Ø¬ Ø§Ù„Ù†Ø§ÙØ°Ø©
                if (searchState.active && (!edge.from.inSearchWindow || !edge.to.inSearchWindow)) {
                    ctx.strokeStyle = 'rgba(50, 50, 50, 0.1)';
                } else {
                    ctx.strokeStyle = `rgba(79, 172, 254, ${edge.opacity * 0.3})`;
                }

                ctx.beginPath();
                ctx.moveTo(edge.from.x, edge.from.y);
                ctx.lineTo(edge.to.x, edge.to.y);
                ctx.stroke();
            });

            // 2. Ø±Ø³Ù… Ø§Ù„Ø¹Ù‚Ø¯
            growNetwork();

            nodes.forEach(node => {
                node.update();
                node.draw(ctx);
            });

            // 3. Ø±Ø³Ù… Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¨Ø­Ø«
            ctx.globalCompositeOperation = 'source-over';
            drawSearchOverlay(ctx);

            // Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø± (Highlight) ÙÙ‚Ø· Ø¹Ù†Ø¯ Ø¹Ø¯Ù… Ø§Ù„Ø¨Ø­Ø«
            if (hoveredNode && !searchState.active) {
                ctx.globalCompositeOperation = 'screen';
                ctx.lineWidth = 2;
                ctx.strokeStyle = CONFIG.colors.highlightPath;
                ctx.shadowBlur = 10;
                ctx.shadowColor = CONFIG.colors.highlightPath;
                let current = hoveredNode;
                ctx.beginPath();
                while (current.parent) {
                    ctx.moveTo(current.x, current.y);
                    ctx.lineTo(current.parent.x, current.parent.y);
                    current = current.parent;
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            let found = false;
            hoveredNode = null;

            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                if (searchState.active && !node.inSearchWindow) continue;

                const dx = mouseX - node.x;
                const dy = mouseY - node.y;
                const hitRadius = Math.max(node.radius, 10);

                if (dx * dx + dy * dy < hitRadius * hitRadius) {
                    canvas.style.cursor = 'pointer';
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY + 15) + 'px';

                    document.getElementById('tooltip-user').innerText = node.data.user;
                    document.getElementById('tooltip-text').innerText = node.data.content;
                    hoveredNode = node;
                    found = true;
                    break;
                }
            }

            if (!found) {
                canvas.style.cursor = 'default';
                tooltip.style.display = 'none';
                hoveredNode = null;
            }
        });

        function resetSimulation() {
            cancelAnimationFrame(animationFrameId);
            init();
            animate();
        }

        init();
        animate();

    </script>
</body>

</html>