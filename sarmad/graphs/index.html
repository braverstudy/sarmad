<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªØªØ¨Ø¹ ØµØ¯Ù‰ Ø§Ù„Ø§Ù†ØªØ´Ø§Ø± - Viral Spread Visualization</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@300;400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050a14;
            color: white;
            font-family: 'Cairo', sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .header {
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 195, 255, 0.7);
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
            letter-spacing: 1px;
            color: #4facfe;
        }

        .header p {
            margin: 5px 0 0;
            font-size: 14px;
            color: #aaa;
            transition: color 0.3s ease;
        }

        .timeline-bar {
            position: relative;
            width: 100%;
            height: 60px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 40px;
            box-sizing: border-box;
        }

        .time-label {
            font-size: 14px;
            color: #4facfe;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid rgba(79, 172, 254, 0.3);
        }

        .controls {
            pointer-events: auto;
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }

        button {
            border: none;
            padding: 10px 20px;
            color: white;
            border-radius: 25px;
            font-family: 'Cairo', sans-serif;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-reset {
            background: linear-gradient(45deg, #00f260, #0575e6);
            box-shadow: 0 4px 15px rgba(0, 242, 96, 0.4);
        }

        .btn-trace {
            background: linear-gradient(45deg, #ff416c, #ff4b2b);
            box-shadow: 0 4px 15px rgba(255, 65, 108, 0.4);
        }

        button:hover {
            transform: translateX(-50%) scale(1.05);
            filter: brightness(1.2);
        }

        button:active {
            transform: translateX(-50%) scale(0.95);
        }

        #tooltip {
            position: absolute;
            background: rgba(16, 25, 40, 0.95);
            border: 1px solid #4facfe;
            padding: 10px;
            border-radius: 8px;
            display: none;
            pointer-events: none;
            max-width: 250px;
            box-shadow: 0 0 20px rgba(79, 172, 254, 0.2);
            font-size: 12px;
            color: #eee;
            z-index: 10;
        }

        .tweet-header {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 5px;
        }

        .tweet-avatar {
            width: 20px;
            height: 20px;
            background: #4facfe;
            border-radius: 50%;
            margin-left: 8px;
        }

        /* Ù†Ø§ÙØ°Ø© Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ø¨Ø­Ø« */
        #search-info {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff416c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            display: none;
            text-align: center;
            z-index: 5;
        }

        #search-info h3 {
            margin: 0 0 5px 0;
            color: #ff416c;
            font-size: 16px;
        }

        #search-info span {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
        }
    </style>
</head>

<body>

    <div id="canvas-container">
        <canvas id="networkCanvas"></canvas>
    </div>

    <div id="ui-layer">
        <div class="header">
            <h1>ØªØ­Ù„ÙŠÙ„ Ø§Ù†ØªØ´Ø§Ø± Ø§Ù„Ù…Ø­ØªÙˆÙ‰ - Network Graph</h1>
            <p id="status-text">Ù…Ù† Ø§Ù„Ù…ØµØ¯Ø± (Ø§Ù„ÙŠØ³Ø§Ø±) Ø¥Ù„Ù‰ Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„ÙÙŠØ±ÙˆØ³ÙŠ (Ø§Ù„ÙŠÙ…ÙŠÙ†)</p>
        </div>

        <!-- Ù†Ø§ÙØ°Ø© Ù…Ù†Ø¨Ø«Ù‚Ø© Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨Ø­Ø« -->
        <div id="search-info">
            <h3>Binary Search Window</h3>
            Ù†Ø·Ø§Ù‚ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø­Ø§Ù„ÙŠ: <span id="search-count">0</span> ØªØºØ±ÙŠØ¯Ø©
        </div>

        <div class="controls">
            <button class="btn-trace" onclick="startBinarySearch()">Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…ØµØ¯Ø± (Binary Search) ğŸ”</button>
            <button class="btn-reset" onclick="resetSimulation()">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© âŸ³</button>
        </div>

        <div class="timeline-bar">
            <div class="time-label">Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (Ø§Ù„Ù…Ù†Ø´ÙˆØ± Ø§Ù„Ø£ØµÙ„ÙŠ)</div>
            <div
                style="flex-grow: 1; height: 1px; background: linear-gradient(to left, #4facfe, transparent); margin: 0 20px;">
            </div>
            <div class="time-label">Ø§Ù„Ø¢Ù† (Ø§Ù†ØªØ´Ø§Ø± ÙˆØ§Ø³Ø¹)</div>
        </div>
    </div>

    <div id="tooltip">
        <div class="tweet-header">
            <div class="tweet-avatar"></div>
            <span id="tooltip-user">User123</span>
        </div>
        <div id="tooltip-text">Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØºØ±ÙŠØ¯Ø©...</div>
    </div>

    <script>
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');
        const statusText = document.getElementById('status-text');
        const searchInfoBox = document.getElementById('search-info');
        const searchCountText = document.getElementById('search-count');

        let width, height;
        let nodes = [];
        let edges = [];
        let animationFrameId;
        let hoveredNode = null;

        // Ø­Ø§Ù„Ø© Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠ (Binary Search State)
        let searchState = {
            active: false,
            minX: 0,
            maxX: 0,        // Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
            currentSplitX: 0, // Ù…ÙƒØ§Ù† Ø®Ø· Ø§Ù„Ù‚Ø³Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠ
            step: 0,        // 0: Idle, 1: Scan, 2: Reject(Wrong Path), 3: Shrink
            timer: 0,
            probes: []      // Ø§Ù„Ø®Ø·ÙˆØ· Ø§Ù„Ø­Ù…Ø±Ø§Ø¡ "Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø®Ø§Ø·Ø¦Ø©"
        };

        const CONFIG = {
            maxNodes: 800,       // Ù‚Ù„Ù„Ù†Ø§ Ø§Ù„Ø¹Ø¯Ø¯ Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ø¨Ø³Ø¨Ø¨ Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø³Ø§ÙØ§Øª
            growSpeed: 2,
            branchChance: 0.12,
            connectionRange: 100,
            colors: {
                root: '#FFD700',
                highLevel: '#00C3FF',
                leaf: '#6e48aa',
                edge: 'rgba(79, 200, 255, 0.4)',
                highlightPath: '#FF4500',
                searchWindow: 'rgba(0, 195, 255, 0.1)',
                searchLine: '#ff416c',
                rejected: 'rgba(255, 65, 108, 0.5)'
            }
        };

        function resizeCanvas() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        class Node {
            constructor(x, y, level, parent = null) {
                this.x = x;
                this.y = y;
                this.originX = x;
                this.originY = y;
                this.level = level;
                this.parent = parent;

                // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø­Ø¬Ù…
                if (level === 0) {
                    this.radius = 25;
                    this.color = CONFIG.colors.root;
                    this.glow = 30;
                } else {
                    this.radius = Math.max(2, 12 * Math.pow(0.85, level));
                    this.color = level < 5 ? CONFIG.colors.highLevel : 'rgba(150, 200, 255, 0.6)';
                    this.glow = level < 3 ? 10 : 0;
                }

                this.opacity = 0;
                this.targetOpacity = 1;
                this.vx = (Math.random() - 0.5) * 0.2;
                this.vy = (Math.random() - 0.5) * 0.2;

                this.isRejected = false; // Ù„Ù„Ø¹Ù‚Ø¯ Ø§Ù„ØªÙŠ ØªÙ… Ø§Ø³ØªØ¨Ø¹Ø§Ø¯Ù‡Ø§ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«

                this.data = {
                    user: level === 0 ? "Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„Ø£ØµÙ„ÙŠ" : `Ù…Ø³ØªØ®Ø¯Ù…_${Math.floor(Math.random() * 9000)}`,
                    content: level === 0 ? "Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ù‚ØµØ© ÙˆØ§Ù„Ø­Ø¯Ø«..." : "ØªÙØ§Ø¹Ù„ØŒ Ø±ÙŠØªÙˆÙŠØªØŒ Ø£Ùˆ Ø±Ø¯..."
                };
            }

            update() {
                if (this.opacity < this.targetOpacity) {
                    this.opacity += 0.05;
                }
                // Ø­Ø±ÙƒØ© Ø¨Ø³ÙŠØ·Ø©
                this.x += this.vx;
                this.y += this.vy;
                const drift = 5;
                if (this.x > this.originX + drift || this.x < this.originX - drift) this.vx *= -1;
                if (this.y > this.originY + drift || this.y < this.originY - drift) this.vy *= -1;
            }

            draw(ctx) {
                ctx.globalAlpha = this.opacity;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                // Ø¥Ø°Ø§ ØªÙ… Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ø¹Ù‚Ø¯Ø©ØŒ Ù†Ø±Ø³Ù…Ù‡Ø§ Ø¨Ù„ÙˆÙ† Ø¨Ø§Ù‡Øª Ø£Ùˆ Ø£Ø­Ù…Ø±
                if (this.isRejected) {
                    ctx.fillStyle = '#333'; // Ù„ÙˆÙ† Ù…Ø·ÙØ£
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else {
                    if (this.glow > 0) {
                        ctx.shadowBlur = this.glow;
                        ctx.shadowColor = this.color;
                    } else {
                        ctx.shadowBlur = 0;
                    }
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }

                ctx.shadowBlur = 0;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 1;
            }
        }

        function init() {
            nodes = [];
            edges = [];
            searchState.active = false;
            searchInfoBox.style.display = 'none';
            statusText.innerText = "Ù…Ù† Ø§Ù„Ù…ØµØ¯Ø± (Ø§Ù„ÙŠØ³Ø§Ø±) Ø¥Ù„Ù‰ Ø§Ù„ØªÙØ§Ø¹Ù„ Ø§Ù„ÙÙŠØ±ÙˆØ³ÙŠ (Ø§Ù„ÙŠÙ…ÙŠÙ†)";
            statusText.style.color = "#aaa";

            // Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙÙŠ Ø§Ù„Ù…Ù†ØªØµÙ Ø§Ù„Ø£ÙŠØ³Ø±
            const rootNode = new Node(80, height / 2, 0);
            nodes.push(rootNode);
        }

        // --- ÙˆØ¸ÙŠÙØ© Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø«Ù†Ø§Ø¦ÙŠ (Binary Search Algorithm) ---
        function startBinarySearch() {
            if (nodes.length < 20) {
                alert("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù†ØªØ´Ø§Ø± Ø§Ù„Ø´Ø¨ÙƒØ© Ù‚Ù„ÙŠÙ„Ø§Ù‹!");
                return;
            }

            searchState.active = true;
            searchState.minX = 0;
            searchState.maxX = width; // Ù†Ø¨Ø¯Ø£ Ø¨Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„ÙƒØ§Ù…Ù„
            searchState.step = 1; // Scan Phase
            searchState.timer = 0;
            searchState.probes = [];

            // Ø¥Ø¹Ø§Ø¯Ø© ØªÙ„ÙˆÙŠÙ† Ø§Ù„Ø¹Ù‚Ø¯
            nodes.forEach(n => n.isRejected = false);

            searchInfoBox.style.display = 'block';
            statusText.innerText = "Ø¬Ø§Ø±ÙŠ ØªÙ†ÙÙŠØ° Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Binary Search Ø§Ù„Ø²Ù…Ù†ÙŠØ© Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…ØµØ¯Ø±...";
            statusText.style.color = CONFIG.colors.searchLine;
        }

        function growNetwork() {
            // ØªÙˆÙ‚Ù Ø§Ù„Ù†Ù…Ùˆ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«
            if (searchState.active) return;
            if (nodes.length >= CONFIG.maxNodes) return;

            const activeNodes = nodes.filter(n => n.x < width - 100 && Math.random() < 0.4);

            for (let parent of activeNodes) {
                if (Math.random() < CONFIG.branchChance) {
                    const angleSpread = Math.PI / 1.2;
                    const angle = (Math.random() - 0.5) * angleSpread;

                    // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù…Ø³Ø§ÙØ© Ù‡Ù†Ø§ (More Spacing)
                    const distance = 50 + Math.random() * 100; // ÙƒØ§Ù†Øª 20+60

                    const newX = parent.x + Math.abs(Math.cos(angle) * distance) + (Math.random() * 20);
                    const newY = parent.y + Math.sin(angle) * distance;

                    if (newY > 40 && newY < height - 40 && newX < width - 40) {
                        const newLevel = parent.level + 1;
                        const newNode = new Node(newX, newY, newLevel, parent);
                        nodes.push(newNode);
                        edges.push({ from: parent, to: newNode, opacity: 0 });
                        if (nodes.length >= CONFIG.maxNodes) break;
                    }
                }
            }
        }

        function updateSearchAnimation() {
            if (!searchState.active) return;

            searchState.timer++;

            // Ø­Ø³Ø§Ø¨ Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù‚Ø¯ ÙÙŠ Ø§Ù„Ù†Ø·Ø§Ù‚ Ø§Ù„Ù†Ø´Ø· (ÙŠØ³Ø§Ø± Ø§Ù„Ø®Ø·)
            const activeNodesCount = nodes.filter(n => n.x >= searchState.minX && n.x <= searchState.maxX && !n.isRejected).length;
            searchCountText.innerText = activeNodesCount;

            // Phase 1: ØªØ­Ø¯ÙŠØ¯ Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ù†ØªØµÙ (Scan)
            if (searchState.step === 1) {
                // Ø§Ù„Ù‡Ø¯Ù Ù‡Ùˆ Ù…Ù†ØªØµÙ Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
                const mid = (searchState.minX + searchState.maxX) / 2;
                searchState.currentSplitX = mid; // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø®Ø· Ù„Ù„Ù…Ù†ØªØµÙ

                // Ø¹Ù†Ø¯Ù…Ø§ ÙŠØ³ØªÙ‚Ø± Ø§Ù„Ø®Ø·
                if (searchState.timer > 30) {
                    searchState.step = 2; // Ø§Ù†ØªÙ‚Ù„ Ù„Ù…Ø±Ø­Ù„Ø© "Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø®Ø§Ø·Ø¦Ø©"
                    searchState.timer = 0;

                    // Ø¥Ù†Ø´Ø§Ø¡ "Ù…Ø¬Ø³Ø§Øª" (Probes) Ù„Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ÙŠÙ…Ù†Ù‰ (Ø§Ù„ØªÙŠ Ø³ÙŠØªÙ… Ø§Ø³ØªØ¨Ø¹Ø§Ø¯Ù‡Ø§)
                    // Ù‡Ø°Ù‡ ØªÙ…Ø«Ù„ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„ØªÙŠ ØªÙØ­ØµÙ‡Ø§ Ø§Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© ÙˆØªØ¬Ø¯ Ø£Ù†Ù‡Ø§ "Ø­Ø¯ÙŠØ«Ø© Ø¬Ø¯Ø§Ù‹"
                    searchState.probes = [];
                    const nodesInRejectZone = nodes.filter(n => n.x > mid && n.x <= searchState.maxX && !n.isRejected);

                    // Ù†Ø®ØªØ§Ø± Ø¨Ø¹Ø¶ Ø§Ù„Ø¹Ù‚Ø¯ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹ Ù„Ù†Ø¸Ù‡Ø± "Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù‡Ø§"
                    const samples = nodesInRejectZone.sort(() => 0.5 - Math.random()).slice(0, 5);

                    samples.forEach(target => {
                        searchState.probes.push({
                            x1: mid, y1: height / 2, // Ù…Ù† Ø®Ø· Ø§Ù„Ø¨Ø­Ø«
                            x2: target.x, y2: target.y, // Ø¥Ù„Ù‰ Ø§Ù„Ø¹Ù‚Ø¯Ø©
                            life: 1.0,
                            targetNode: target
                        });
                    });
                }
            }

            // Phase 2: Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø®Ø§Ø·Ø¦Ø© (Wrong Paths / Dead Ends)
            else if (searchState.step === 2) {
                // ØªÙ‚Ù„ÙŠÙ„ Ø¹Ù…Ø± Ø§Ù„Ø®Ø·ÙˆØ·
                let stillAlive = false;
                searchState.probes.forEach(p => {
                    p.life -= 0.05;
                    if (p.life > 0) stillAlive = true;
                });

                if (searchState.timer > 20) { // Ø¨Ø¹Ø¯ ÙˆÙ…ÙŠØ¶ Ø§Ù„Ø®Ø·ÙˆØ·
                    // Ø§Ø³ØªØ¨Ø¹Ø§Ø¯ Ø§Ù„Ø¹Ù‚Ø¯ ÙÙŠ Ø§Ù„Ù†ØµÙ Ø§Ù„Ø£ÙŠÙ…Ù†
                    nodes.forEach(n => {
                        if (n.x > searchState.currentSplitX && n.x <= searchState.maxX) {
                            n.isRejected = true;
                        }
                    });

                    searchState.step = 3;
                    searchState.timer = 0;
                }
            }

            // Phase 3: ØªÙ‚Ù„ÙŠØµ Ø§Ù„Ù†Ø§ÙØ°Ø© (Shrink Window)
            else if (searchState.step === 3) {
                // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ø¥Ù„Ù‰ Ù†Ù‚Ø·Ø© Ø§Ù„Ø§Ù†Ù‚Ø³Ø§Ù…
                searchState.maxX = searchState.currentSplitX;

                if (activeNodesCount <= 1 || searchState.maxX < 150) {
                    // ÙˆØµÙ„Ù†Ø§ Ù„Ù„Ù†Ù‡Ø§ÙŠØ©!
                    searchState.active = false;
                    searchInfoBox.style.display = 'none';
                    statusText.innerText = "ØªÙ… Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…ØµØ¯Ø± Ø§Ù„Ø£ØµÙ„ÙŠ (Ø£Ù‚Ø¯Ù… ØªØºØ±ÙŠØ¯Ø©)!";
                    statusText.style.color = "#00f260";

                    // ØªØ³Ù„ÙŠØ· Ø§Ù„Ø¶ÙˆØ¡ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØµØ¯Ø±
                    nodes[0].glow = 100;
                    nodes[0].radius = 50;
                } else {
                    // ØªÙƒØ±Ø§Ø± Ø§Ù„Ø­Ù„Ù‚Ø©
                    searchState.step = 1;
                    searchState.timer = 0;
                }
            }
        }

        function drawSearchOverlay(ctx) {
            if (!searchState.active) return;

            const splitX = searchState.currentSplitX;

            // 1. ØªØ¸Ù„ÙŠÙ„ Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø³ØªØ¨Ø¹Ø¯Ø© (ÙŠÙ…ÙŠÙ† Ø§Ù„Ø®Ø·)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(splitX, 0, width - splitX, height);

            // 2. ØªØ¸Ù„ÙŠÙ„ Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù†Ø´Ø·Ø© (ÙŠØ³Ø§Ø± Ø§Ù„Ø®Ø·)
            ctx.fillStyle = CONFIG.colors.searchWindow;
            ctx.fillRect(0, 0, splitX, height);

            // 3. Ø±Ø³Ù… Ø®Ø· Ø§Ù„Ù…Ø³Ø­ (Scan Line)
            ctx.beginPath();
            ctx.moveTo(splitX, 0);
            ctx.lineTo(splitX, height);
            ctx.strokeStyle = CONFIG.colors.searchLine;
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);

            // 4. Ø±Ø³Ù… Ù…Ø¬Ø³Ø§Øª Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø®Ø§Ø·Ø¦Ø© (Probes)
            if (searchState.step === 2) {
                searchState.probes.forEach(p => {
                    if (p.life <= 0) return;

                    ctx.beginPath();
                    ctx.moveTo(p.x1, p.y1);
                    ctx.lineTo(p.x2, p.y2);
                    ctx.strokeStyle = `rgba(255, 65, 108, ${p.life})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    // Ø¹Ù„Ø§Ù…Ø© X ØµØºÙŠØ±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù‚Ø¯Ø© Ø§Ù„Ù…Ø³ØªÙ‡Ø¯ÙØ©
                    if (p.life > 0.5) {
                        ctx.beginPath();
                        ctx.arc(p.targetNode.x, p.targetNode.y, p.targetNode.radius + 5, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(255, 65, 108, ${p.life})`;
                        ctx.stroke();
                    }
                });
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            ctx.globalCompositeOperation = 'screen';

            // ØªØ­Ø¯ÙŠØ« Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¨Ø­Ø«
            updateSearchAnimation();

            // 1. Ø±Ø³Ù… Ø§Ù„Ø®Ø·ÙˆØ·
            ctx.lineWidth = 0.8;
            edges.forEach(edge => {
                if (edge.opacity < 1) edge.opacity += 0.02;

                // Ù†Ø®ÙÙ Ø§Ù„Ø®Ø·ÙˆØ· Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø¹Ù‚Ø¯ Ù…Ø³ØªØ¨Ø¹Ø¯Ø©
                if (edge.to.isRejected) {
                    ctx.strokeStyle = 'rgba(50, 50, 50, 0.2)';
                } else {
                    ctx.strokeStyle = `rgba(79, 172, 254, ${edge.opacity * 0.3})`;
                }

                ctx.beginPath();
                ctx.moveTo(edge.from.x, edge.from.y);
                ctx.lineTo(edge.to.x, edge.to.y);
                ctx.stroke();
            });

            // 2. Ø±Ø³Ù… Ø§Ù„Ø¹Ù‚Ø¯
            growNetwork();

            nodes.forEach(node => {
                node.update();
                node.draw(ctx);
            });

            // 3. Ø±Ø³Ù… Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¨Ø­Ø« (Search Overlay) ÙÙˆÙ‚ ÙƒÙ„ Ø´ÙŠØ¡
            ctx.globalCompositeOperation = 'source-over';
            drawSearchOverlay(ctx);

            // Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø± Ø¹Ù†Ø¯ Ø§Ù„ØªÙ…Ø±ÙŠØ± (ÙÙ‚Ø· Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ù„Ø¨Ø­Ø« Ù†Ø´Ø·Ø§Ù‹)
            if (hoveredNode && !searchState.active) {
                ctx.globalCompositeOperation = 'screen';
                ctx.lineWidth = 2;
                ctx.strokeStyle = CONFIG.colors.highlightPath;
                ctx.shadowBlur = 10;
                ctx.shadowColor = CONFIG.colors.highlightPath;
                let current = hoveredNode;
                ctx.beginPath();
                while (current.parent) {
                    ctx.moveTo(current.x, current.y);
                    ctx.lineTo(current.parent.x, current.parent.y);
                    current = current.parent;
                }
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            let found = false;
            hoveredNode = null;

            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                // Ù„Ø§ Ù†ØªÙØ§Ø¹Ù„ Ù…Ø¹ Ø§Ù„Ø¹Ù‚Ø¯ Ø§Ù„Ù…Ø³ØªØ¨Ø¹Ø¯Ø© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«
                if (searchState.active && node.isRejected) continue;

                const dx = mouseX - node.x;
                const dy = mouseY - node.y;
                const hitRadius = Math.max(node.radius, 10); // Ø²ÙŠØ§Ø¯Ø© Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù†Ù‚Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù…Ø¹ Ø§Ù„ØªØ¨Ø§Ø¹Ø¯

                if (dx * dx + dy * dy < hitRadius * hitRadius) {
                    canvas.style.cursor = 'pointer';
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY + 15) + 'px';

                    document.getElementById('tooltip-user').innerText = node.data.user;
                    document.getElementById('tooltip-text').innerText = node.data.content;
                    hoveredNode = node;
                    found = true;
                    break;
                }
            }

            if (!found) {
                canvas.style.cursor = 'default';
                tooltip.style.display = 'none';
                hoveredNode = null;
            }
        });

        function resetSimulation() {
            cancelAnimationFrame(animationFrameId);
            init();
            animate();
        }

        init();
        animate();

    </script>
</body>

</html>